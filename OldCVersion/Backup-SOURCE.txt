#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>
#define _WIN32_WINNT 0x0500 //must be before windows.h for mystical reasons such as widnows.h overwrites it with not right thing - for minimizing console window
#include <windows.h>
#include <shellapi.h> // make some system tray stuff go on
#define WM_MYMESSAGE (WM_APP + 100) //for that tray icon
#define sleep(x) Sleep(1000 * x) //fix for everywhere you google is Linux that is sleep while Windows is Sleep so it renames it and makes it count in seconds

#define maxLocaleLength 1024 // Maximum length allowed
#define maxPathUNC 32767 //max UNC length allowed, unused atm
//UNC not fully supported b/c it goes to ~32,767 and this is 1024 so
//Max path is apparently more like 255 or 260 depending on where you are at the time, unless its specially enabled in Win10 but we don't talk about that go away

//GOAL: RUN ROBOCOPY TO COPY FILES FROM LIST OF SOURCES TO DESTINATION. READ DESTINATION LOCATION AND SOURCE LIST FROM TEXT FILES.
int main()
{
    //Suppress command window so it doesn't steal screen real-estate and bump out of movies etc.
    HWND hWnd = GetConsoleWindow(); // from https://stackoverflow.com/questions/11812095/hide-the-console-window-of-a-c-program via Anthropos
    //ShowWindow( hWnd, SW_MINIMIZE );  //won't hide the window without SW_MINIMIZE https://msdn.microsoft.com/en-us/library/windows/desktop/ms633548(v=vs.85).aspx check this
    ShowWindow( hWnd, SW_HIDE ); //hides the window so it leaves taskbar etc
    //ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error (here for debugging)

    //System Tray Icon support - here it is
    NOTIFYICONDATA nid; //thing that has info on window and system tray stuff in it
    nid.cbSize = sizeof(NOTIFYICONDATA); //prep
    nid.hWnd = hWnd; //links the console window
    nid.uID = 1001; //it's a number
    nid.uCallbackMessage = WM_MYMESSAGE; //whoknows should be related to click capture but doesn't so
    nid.hIcon = LoadIcon(NULL, IDI_APPLICATION); //icon idk
    strcpy(nid.szTip, "Basic Bitch Backup is running in the background"); //tooltip for the icon
    nid.szTip[47] = '\0'; //null at the end of it
    nid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP; //who knows
    size_t nidszTipLength = sizeof(nid.szTip) / sizeof(nid.szTip[0]); //gets the size of nid.szTip (tooltip length)

    Shell_NotifyIcon(NIM_ADD, &nid); //shows the icon

    //printf("\nIDI_APPLICATION: %f\n",NULL);
    //system("pause");

    //Introduce program
    printf("  ____           _____ _____ _____   ____ _____ _______ _____ _    _   ____          _____ _  ___    _ _____  \n");
    printf(" |  _ \\   /\\    / ____|_   _/ ____| |  _ \\_   _|__   __/ ____| |  | | |  _ \\   /\\   / ____| |/ / |  | |  __ \\ \n");
    printf(" | |_) | /  \\  | (___   | || |      | |_) || |    | | | |    | |__| | | |_) | /  \\ | |    | ' /| |  | | |__) |\n");
    printf(" |  _ < / /\\ \\  \\___ \\  | || |      |  _ < | |    | | | |    |  __  | |  _ < / /\\ \\| |    |  < | |  | |  ___/ \n");
    printf(" | |_) / ____ \\ ____) |_| || |____  | |_) || |_   | | | |____| |  | | | |_) / ____ \\ |____| . \\| |__| | |     \n");
    printf(" |____/_/    \\_\\_____/|_____\\_____| |____/_____|  |_|  \\_____|_|  |_| |____/_/    \\_\\_____|_|\\_\\\\____/|_|     \n");
    printf("\t\t\tNota Bene: Omne plebes sunt elementa canes in meo oculo.\n");
    //Any gender can be a basic bitch so don't get too hung up on it this is gender-inclusive. #woke?

    //***************************DECLARE CONSTANT-SIZED VARIABLES*************************************************************
    //FILE-READING RELATED STUFF
    FILE *fdest; //file pointer for destination text file
    FILE *fsaves; //file pointer for save locations text file
    char c; // prep character reader
    int saves_numberNOTYET = 0; //counter for number of save lines (temp to determine real lines)
    int saves_number = 0; //counter for number of save lines
    char saves_localesTemp[maxLocaleLength-1] = {'\0'}; //prep temporary holder for save locales, -1 for removing colon (e.g. C:\ -> C\)
    char destination[maxLocaleLength] = {'\0'}; //prep destination location
    int destinationLength = 0; //prep destination length
    int destination_savesLengthMax = 0; //prep
    char destinationFilePath[maxLocaleLength] = {'\0'}; //prep direct destination location
    char saveFilePath[maxLocaleLength] = {'\0'}; //prep direct save file location

    //COUNTERS AND FLAGS THAT ARE REUSED A LOT #NOTMYVARIABLE
    int i; //legit only counter or flag
    int j; //legit only counter or flag
    int k; //legit only counter or flag
    int m; //legit only counter or flag
    int n; //legit only counter or flag

    //PATH-CREATING STUFF
    int pathLength = 0; //prep (NOT related to pathBase)
    char pathHolder[maxLocaleLength] = {'0'}; //prep n clear
    char pathBase[maxLocaleLength] = {'\0'}; //prep n clear
    DWORD compNameSize = MAX_COMPUTERNAME_LENGTH + 1 ; //prep reading comp name
    char compNameBuffer[MAX_COMPUTERNAME_LENGTH + 1]; //prep reading comp name

    //COMMAND-RELATED STUFF
    char commandTemp1[10] = "robocopy "; //make sure you count those numbers
    commandTemp1[9] = '\0';
    char commandTemp2[46] = " /MIR /copy:DAT /MT:32 /Z /R:2 /W:03 /v /LOG:"; //make sure you count those numbers //removed /eta
    commandTemp2[45] = '\0'; //make sure this is -1 of above and below is THE SAME
    int commandTemp2Size = 45; //key for code below
    int commandSize = 0; //prep, changes based on source

    char *command; //prep for DYNAMIC MEMORY ALLOCATION

    FILE *fcheck; //file pointer for checking log file
    char roboErrorTwo[48] = "ERROR 2 (0x00000002) Accessing Source Directory"; //within robocopy log file - error means source directory does not exist
    roboErrorTwo[47] = '\0';
    int roboErrorTwoLength = 47; //required for ez stuff
    char roboErrorThree[52] = "ERROR 3 (0x00000003) Creating Destination Directory"; //within robocopy log file - error means destination directory does not exist
    roboErrorThree[51] = '\0';
    int roboErrorThreeLength = 51; //required for ez stuff
    FILE* fchecklog; //file pointer for making a log file backup after a "between 1 and all-1 file copy failure" warning
    char roboWarningLogSaveAddition[20] = "FILECOPYFAILURE.log"; // save this for adding
    roboWarningLogSaveAddition[19] = '\0'; //null it and the end
    int roboWarningLogSaveAdditionLength = 19; //required for ez stuff
    int roboWarningLogNumberFinder = 1; //prep this counter

    char sysTrayTemp1[maxLocaleLength] = {'\0'}; //prep system tray temp
    char sysTrayTemp2[maxLocaleLength] = {'\0'}; //prep system tray temp

    if(nidszTipLength > maxLocaleLength)
    {
        nidszTipLength = maxLocaleLength; //prevent buffer overflow from changing Windows parameters (but really I doubt they'd ever change, it's 64 right now)
    }

    //***************************DECLARE FUNCTION IS GOING DOWN*************************************************************
    printf("\n*********************BACKUP PROGRAM HAS BEEN ENGAGED*********************\n");


    //***************************FIND RUNNING PATH*************************************************************
    //Some sick-nasty code I found to get the path of the excutable it uses hardcore stuff
    //hmjd @ https://stackoverflow.com/questions/9112893/how-to-get-path-to-executable-in-c-running-on-windows
    DWORD last_error;
    DWORD result;
    DWORD path_size = 1024;
    char* path = malloc(1024);
    //this stuff stays here because it is buds with the stuff below and idk whatever go away it works

    for (;;) //what even
    {
        memset(path, 0, path_size);
        result = GetModuleFileName(0, path, path_size - 1);
        last_error = GetLastError();

        if (0 == result)
        {
            free(path);
            path = 0;
            break;
        }
        else if (result == path_size - 1)
        {
            free(path);
            /* May need to also check for ERROR_SUCCESS here if XP/2K */
            if (ERROR_INSUFFICIENT_BUFFER != last_error)
            {
                path = 0;
                break;
            }
            path_size = path_size * 2;
            path = malloc(path_size);
        }
        else
        {
            break;
        }
    }

    if (!path)
    {
        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
        printf("\n************************************************************************************\n");
        printf("ERORR: Path exe finding error failure: %d\nI'm not sure why it failed or what to do about that so sorry lad&orlass\nEXITINGGG SRRY SO SRRY\n", last_error);
        system("pause"); //pause for user input
        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
        return 4;
    }
    /*else
    {
        printf("path=%s\n", path);

    } */
    strncpy(pathHolder,path,maxLocaleLength); //copy to non-dynamic memory

    pathLength = strlen(pathHolder); //get the path length
    //printf("STR LEN = %d\nPRINTING PATH:\n",pathLength);
    k = 0; //prep place finder
    for( i = 0; i < pathLength; i++)
    {
        //printf("%c",pathHolder[i]);
        if( pathHolder[i] == '\\')
        {
            k = i; //record last \ with this
        }
    }
    strncpy(pathBase,pathHolder,k+1); //copy path base to string
    //printf("PATH BASE: %s\n",pathBase);

    //CREATE DIRECT DESTINATION FILE LOCALE AND SAVE FILE LOCALE FOR GUARANTEED READING
    //printf("STRING MAKING\n");
    if( (pathLength+29) > maxLocaleLength ) //make sure we don't go over the limit (29 is length of Backup_destinationLocale.txt and a '\0' null char)
    {
        printf("Error - Max char limit for file location where destination locale is held, rest was cut off - only using relative path %s\nIt's gonna error out later sorry so sorry lass&orlad\n","Backup_destinationLocale.txt");
        strncat(destinationFilePath, "Backup_destinationLocale.txt", maxLocaleLength-1); //create destination file path
    }
    else
    {
        strncat(destinationFilePath, pathBase, maxLocaleLength-1);
        strncat(destinationFilePath, "Backup_destinationLocale.txt",maxLocaleLength-1-strlen(pathBase)); //create destination file path
    }

    if( (pathLength+22) > maxLocaleLength ) //make sure we don't go over the limit (22 is length of Backup_saveLocales.txt and a '\0' null char)
    {
        printf("Error - Max char limit for file location where save locales are held, rest was cut off - only using relative path %s\nIt's gonna error out later sorry so sorry lass&orlad\n","Backup_saveLocales.txt");
        strncat(saveFilePath, "Backup_saveLocales.txt", maxLocaleLength-1); //create destination file path
    }
    else
    {
        strncat(saveFilePath, pathBase, maxLocaleLength-1);
        strncat(saveFilePath, "Backup_saveLocales.txt", maxLocaleLength-1-strlen(pathBase)); //create save file path
    }


    //printf("dest %s\nsave %s\n",destinationFilePath,saveFilePath);

    //***************************OPEN AND READ DESTINATION LOCATION*************************************************************
    fdest = fopen(destinationFilePath,"r"); //read backup destination

    if( fdest == 0)
    {
        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
        printf("\n************************************************************************************\n");
        printf("ERROR: No destination location file found, giving up.\n");
        system("pause"); //pause for user input
        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
        return 1; //1 for sass
    }

    j = 0; // prep counter
    k = -1; // prep over char limit flag
    i = 0; //prep flag for end of line (shouldn't be multiple lines)
    while( (c = fgetc(fdest)) != EOF ) //runs till hits end of file
    {
        if( (c != '\n') && (i == 0) )
        {
            if(j < maxLocaleLength)
            {
                destination[j] = c; //save the char
                j = j + 1; //increment char counter
            }
            else
            {
                //if more than max length then ignoring rest to prevent BUFFER OVERFLOP is this how you do it I DON'T KNOW
                k = 99999; //save line this happened on
            }
        }
        else
        {
            i = 1; //new line found, flag on so we ignore other lines
        }
    }
    if( k >= 0) //report error of cutting off directory line if it was too long
    {
        printf("Error - Max char limit for destination directory hit, rest was cut off\nIt's gonna error out later sorry so sorry lass&orlad\n");
    }
    destinationLength = j; //record destination length
    k = 0; //reuse as a counter asap
    for(i = 0; i < maxLocaleLength; i++)
    {
        k = k + isalpha(destination[i]);
    }
    if( (destinationLength == 0) || (k == 0) )
    {
        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
        printf("\n************************************************************************************\n");
        printf("ERROR: No destination location in file found, giving up.\n");
        system("pause"); //pause for user input
        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
        return 2; //2 for sass
    }

    fclose(fdest); //closes this file

    //REPORT DESTINATION
//    printf("Backup Destination:\n");
//    for(j = 0; j < maxLocaleLength; j++)
//    {
//        printf("%c",destination[j]);
//    }
//    printf("\n\n");
    printf("Backup Destination:\n%s\n\n",destination);

    //***************************DETERMINE IF NETWORK DRIVE*************************************************************
    //DISABLED UNTIL OBVIOUS IT IS NEEDED - IT DOES MAKE A UNC PATH TO THE REQUESTED NETWORK DRIVE THO LET ME TELL YOU ITS REAL

    //READING FROM A COMMAND SOURCED FROM https://stackoverflow.com/questions/646241/c-run-a-system-command-and-get-output
    //THX2BILL it works on Windows too
    FILE *fcmd; //init file pointer for the command stream used to check for full networked drive paths b/c can't talk to them normally
    char cmdReturn[maxLocaleLength] = {'\0'}; //prep n clear
    int FLG_destinationNetwork = 0; //prep flag if a networked destination is detected
    int FLG_destinationNetworkUnavail = 0; //prep flag if a networked destination is currently unavailable
    char *ret; //pointer for strstr
    char retRecord[maxLocaleLength] = {'\0'}; //prep n clear
    char destinationUNC[maxLocaleLength] = {'\0'}; //prep n clear
    char destinationNetworkFixEngage[maxLocaleLength] = {'\0'}; //prep n clear
    //char destinationNetworkFixStart[maxLocaleLength] = {'\0'}; //prep n clear
    //char destinationNetworkFixEnd[maxLocaleLength] = {'\0'}; //prep n clear
    char destinationTwoChar[3] = {'\0'}; //prep n clear (extra is for NULL at end so its a real string)
    for( i = 0; i < 2; i++)
    {
        destinationTwoChar[i] = destination[i]; //write in the first two chars, NO I DON'T KNOW A BETTER WAY SHOVE OFF
    }


    // Open the command stream "net use" which gives networked drives full paths (e.g. \\servername\)
    fcmd = popen("net use", "r"); //run cmd.exe net use
    if (fcmd == NULL) //make sure something happened
    {
        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
        printf("\n************************************************************************************\n");
        printf("ERROR: Failed to run cmd.exe net use to figure out if drive given is a network drive, giving up.\n");
        system("pause"); //pause for user input
        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
        return 1; //1 for sass
    }
    // Read the output a line at a time, dunno how to do it any way else, tried by character #failure
    while (fgets(cmdReturn, sizeof(cmdReturn)-1, fcmd) != NULL)
    {
        //printf("%s", cmdReturn); //rep
        ret = strstr(cmdReturn, destinationTwoChar); //strstr returns NULL if the thing we're looking for (drive letter:)  isn't there
        if(ret != NULL)
        {
            //printf("RET = %s\n",ret);
            i = 0; //counter, prevents over char array
            k = -1; //flag to signify over char array occured
            FLG_destinationNetwork = 1; //turn on flag that it is a networked destination locale
            strncat(retRecord,cmdReturn,maxLocaleLength-1); //copy in the bit that we found to keep ~precious~

            /*while( ret[i] != NULL) //while not NULL idk I made it up it works go away is it ok sure it is
            {
                if(i < maxLocaleLength)
                {
                    retRecord[i] = ret[i]; //records return
                }
                else
                {
                    k = i; //flag over char array length
                }
                i++; //increment
            }
            if( k >= 0) //notify
            {
                printf("Error - Max char limit for destination directory hit, rest was cut off\nIt's gonna error out later sorry so sorry lass&orlad\n");
            }*/
        }
    }
    pclose(fcmd); // Close the command stream, got it

    //printf("RET Recorded = %s\n",retRecord);

    if( FLG_destinationNetwork == 1)
    {
        //printf("\nTEST: NETWORK DESTINATION DETECTED\n");
        k = 0; // flag for finding \\ occurances
        j = 0; //mid-cycle counter
        for( i = 0; i < maxLocaleLength; i++)
        {
            if( (retRecord[i] == '\\') & ((k == 0) | (k == 1)) )
            {
                k++;
            }
            if( k == 2 )
            {
                if( (j > 0) & ((retRecord[i] == '\0') | (retRecord[i] == ' ')) )
                {
                    break; //time to ditch it
                }
                if( j == 0) //first run prep
                {
                    destinationUNC[0] = '\\'; //put in the slashes
                    destinationUNC[1] = '\\';
                    j = 2; //counter to start at
                }
                else
                {
                    destinationUNC[j] = retRecord[i];
                    j++; //increment
                }
            }
        }
        //printf("\nTEST: CHECKING: %s\n",retRecord);
        //Check if network is unavailable
        if( (strstr(retRecord,"Unavailable") != NULL) | (strstr(retRecord,"Disconnected") != NULL) )
        {
            //printf("\nTEST: UNAVAILABLE FOUND\n");
            FLG_destinationNetworkUnavail = 1; //turn on flag that it's unavailable ATM and take steps to make it available
        }
        //else
        //{
           // printf("\nTEST: NETWORK IS AVAILABLE\n");
        //}

        // printf("destinationUNC = %s\n",destinationUNC);

        if( FLG_destinationNetworkUnavail == 1 ) //try to get it going if it's not going
        {
            printf("*********NOTA BENE: Network drive is currently disconnected, attempting to force a reconnection. An error catch will trigger later if reconnection attempt fails.*********\n");
            //NOTE: Add string length checks
            //this could go bad most def yolo
            strncat(destinationNetworkFixEngage, "net use ", maxLocaleLength-1); //add to the string
            strncat(destinationNetworkFixEngage, destinationTwoChar, maxLocaleLength-1-strlen(destinationNetworkFixEngage)); //add to the string
            strncat(destinationNetworkFixEngage, " ", maxLocaleLength-1-strlen(destinationNetworkFixEngage)); //add to the string
            strncat(destinationNetworkFixEngage, destinationUNC, maxLocaleLength-1-strlen(destinationNetworkFixEngage)); //add to the string

            //strcat(destinationNetworkFixStart, "pushd "); //add to the string
            //strcat(destinationNetworkFixStart, destinationUNC); //add to the string

            //strcat(destinationNetworkFixEnd, "popd "); //add to the string
            //strcat(destinationNetworkFixEnd, destinationUNC); //add to the string

            system(destinationNetworkFixEngage); //force some mappin action HARDCORE LOOK OUT
            printf("RAN COMMAND TO FORCE CONNECTION: %s\n\n",destinationNetworkFixEngage); //report command used
            //system(destinationNetworkFixStart); //hopefully engage the drive
        }
    }


    //***************************OPEN AND READ SAVES NUMBER*************************************************************
    fsaves = fopen(saveFilePath,"r"); //read backup source locales

    if( fsaves == 0)
    {
        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
        printf("\n************************************************************************************\n");
        printf("ERROR: No backup source location file found, giving up.\n");
        system("pause"); //pause for user input
        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
        return 1; //1 for sass
    }

    saves_numberNOTYET = 1; //prep counter
    while( (c = fgetc(fsaves)) != EOF) //runs till hits end of file
    {
        if(c == '\n')
        {
            saves_numberNOTYET = saves_numberNOTYET + 1;
        }
    }

    char saves_localesNOTYET[saves_numberNOTYET][maxLocaleLength]; //prep save locale
    int saves_localesMask[saves_numberNOTYET]; //prep saves mask to get real number and real lines
    for(i = 0; i < saves_numberNOTYET; i++)
    {
        for(j = 0; j < maxLocaleLength; j++)
        {
            saves_localesNOTYET[i][j] = '\0'; // fill with nulls
        }
        saves_localesMask[i] = 0; //prime this
    }

    i = 0; //line counter now
    j = 0; //char counter (max is maxLocaleLength)
    k = -1; //flag if error happened
    rewind(fsaves); //go to start of file again
    while( (c = fgetc(fsaves)) != EOF) //runs till hits end of file
    {
        if(c != '\n')
        {
            if(j < maxLocaleLength)
            {
                saves_localesNOTYET[i][j] = c; //save the char
                j = j + 1; //increment char counter
            }
            else
            {
                //if more than max length then ignoring rest to prevent BUFFER OVERFLOP is this how you do it I DON'T KNOW
                k = i; //save line this happened on
            }
        }
        else
        {
            i = i + 1; //increment line counter
            j = 0; //reset char counter

        }
    }
    if( k >= 0) //report error of cutting off directory line if it was too long
    {
        printf("ERROR - Max char limit for save directory hit, rest was cut off - last occurrence was line #%d\nIt's gonna error out later sorry so sorry lass&orlad",k);
    }

    //***************************DETERMINE REAL SAVES NUMBER (AVOID BLANK LINES)*************************************************************
    for(i = 0; i < saves_numberNOTYET; i++)
    {
        for(j = 0; j < maxLocaleLength; j++)
        {
            saves_localesMask[i] = saves_localesMask[i] + isalpha(saves_localesNOTYET[i][j]); //increment
        }
        //printf("Line %d is %d\n",i,saves_localesMask[i]);
    }

    saves_number = 1; //prep counter
    i = 0; //prep counter
    rewind(fsaves); //go to start of file again
    while( (c = fgetc(fsaves)) != EOF) //runs till hits end of file
    {
        if( (c == '\n') && (saves_localesMask[i] > 0) )
        {
            saves_number = saves_number + 1; //increment number of real save locations
            i = i + 1; //increment line counter
        }
    }
    if( saves_localesMask[saves_numberNOTYET-1] == 0 )
    {
        saves_number = saves_number - 1; //de-increment b/c above will not catch the last line since file ends before next line check
    }
    if( saves_number == 0)
    {
        //NOTE: may not activate HOPE IT DOES ALWAYS
        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
        printf("\n************************************************************************************\n");
        printf("ERROR: No backup source locations in file were found, giving up.\n");
        system("pause"); //pause for user input
        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
        return 2; //2 for sass
    }
    printf("Number of save locations: %d\n",saves_number); //print save number

    //***************************SAVE REAL LINES (IGNORE BLANK ONES)*************************************************************
    char saves_locales[saves_number][maxLocaleLength]; //prep save locale
    int saves_localesLength[saves_number]; //prep save locale lengths
        for(i = 0; i < saves_number; i++)
    {
        for(j = 0; j < maxLocaleLength; j++)
        {
            saves_locales[i][j] = '\0'; // fill with nulls
        }
        saves_localesLength[i] = 0; //prime this
    }

    i = 0; //line counter for ALL LINES (save_numberNOTYET)
    m = 0; //line counter for accepted lines (save_number)
    j = 0; //char counter (max is maxLocaleLength)
    k = -1; //flag if error happened
    rewind(fsaves); //go to start of file again
    while( (c = fgetc(fsaves)) != EOF) //runs till hits end of file
    {
        if( (c != '\n') && (saves_localesMask[i] > 0) )
        {
            if(j < maxLocaleLength)
            {
                saves_locales[m][j] = c; //save the char
                j = j + 1; //increment char counter
            }
            else
            {
                //if more than max length then ignoring rest to prevent BUFFER OVERFLOP is this how you do it I DON'T KNOW
                k = i; //save line this happened on
            }
        }
        else if( (c != '\n') && (saves_localesMask[i] == 0) )
        {
            //wait, don't record the line
        }
        else //this happens when c == '\n'
        {
            i = i + 1; //increment line counter
            if( saves_localesMask[i-1] != 0 ) //if last line was a real one, record info about it
            {
                saves_localesLength[m] = j-1; // record the length of the directory, minus one is for removing the colon
                //printf("Line %d, recorded line %d, j-1 is %d\n",i-1,m,j-1);
                j = 0; //reset char counter
                m = m + 1;
            }
        }
    }
    if( m != saves_number ) //if we didn't get all recorded lines, catch the last one
    {
        saves_localesLength[saves_number-1] = j - 1; //get last recorded l for the last time - should align with
    }
    //printf("SAVESLOCALESLENGTH #%d, %d length, j-1 is %d\n",saves_number-1,saves_localesLength[saves_number-1],(j-1));
    //extra one out here because last isn't hit in the loop if it is the last line
    if( k >= 0) //report error of cutting off directory line if it was too long
    {
        printf("ERROR - Max char limit for save directory hit, rest was cut off - last occurrence was line #%d\nIt's gonna error out later sorry lad&orlass\n",k);
    }

    //REPORT LOCATIONS TO BE BACKED-UP
    for(i = 0; i < saves_number; i++)
    {
        //for(j = 0; j < maxLocaleLength; j++)
        //{
        //    printf("%c",saves_locales[i][j]);
        //}
        //printf("\n");

        printf("%s\n",saves_locales[i]);
    }

    fclose(fsaves);

    //***************************FIND COMPUTER NAME*************************************************************
    GetComputerName( compNameBuffer, &compNameSize );

    char compName[compNameSize+2]; //prep comp name var, extras are for a \ and a '0
    for(i = 0; i < compNameSize; i++)
    {
        compName[i] = compNameBuffer[i]; //save it to just the right size
    }
    compName[compNameSize] = '\\'; // end the string correctly
    compName[compNameSize+1] = '\0'; // end the string correctly

    printf("\nComputer Name: ");
    for(i = 0; i < compNameSize; i++)
    {
        printf("%c",compName[i]);
    }
    printf("\n");

    //***************************CREATE DESTINATION FOLDERS*************************************************************
    //FIND max length to know what to preallocate for (maximally)
    int saves_localesLengthMax = 0; //prep max length
    for(i = 0; i < saves_number; i++)
    {
        if(i == 0)
        {
            saves_localesLengthMax = saves_localesLength[i]; //record 1st to start
        }
        else
        {
            if(saves_localesLengthMax < saves_localesLength[i])
            {
                saves_localesLengthMax = saves_localesLength[i]; //record biggest
            }
        }
    }

    destination_savesLengthMax = destinationLength+compNameSize+1+saves_localesLengthMax; //this will be used to preallocate
    //printf("dest saves length max = %d\ndest length = %d\ncompNameSize = %d\nsaves locales = %d\n",destination_savesLengthMax,destinationLength,compNameSize,saves_localesLengthMax);
    char destination_saves[saves_number][destination_savesLengthMax+1]; //prep destination location, +1 puts \0 at end

    for(i = 0; i < saves_number; i++)
    {
        for(j = 0; j < destination_savesLengthMax+1; j++) //+1 puts \0 at end for proper success
        {
            destination_saves[i][j] = '\0'; // fill with nulls
        }
    }

    //Roll through each save locale and create a destination locale for it
    for(i = 0; i < saves_number; i++)
    {
        k = 0; //prep counter

        //THIS BIT records all but the : to make a file path that includes the original drive letter
        for(j = 0; j<maxLocaleLength; j++)
        {
            //printf("i=%d, j=%d, saves locales=%c, strcmp=%d\n",i,j,saves_locales[i][j],saves_locales[i][j]==':');
            if( saves_locales[i][j] != ':' )
            {
                saves_localesTemp[k] = saves_locales[i][j]; //record
                k = k + 1; //increment
            }
            else
            {
                //skip the ":"
            }
        }

        //Build the destination location for each originating save location
        for(j = 0; j<destinationLength; j++)
        {
            destination_saves[i][j] = destination[j]; //put in the destination start
        }
        for(j = destinationLength; j<(destinationLength+compNameSize+1); j++) //+1 is for extra \ at end of compName
        {
            destination_saves[i][j] = compName[j-destinationLength]; //put in the comp name in
        }
        for(j = destinationLength+compNameSize+1; j<(destinationLength+compNameSize+1+saves_localesLength[i]); j++) //+1 is for extra \ at end of compName
        {
            destination_saves[i][j] = saves_localesTemp[j-(destinationLength+compNameSize+1)]; //put in the save location so it mirrors real one (mostly)
        }
    }


    //REPORT
    printf("Destination Saves:\n");
    for(i = 0; i < saves_number; i++)
    {
//        for(j = 0; j < destination_savesLengthMax; j++)
//        {
//            printf("%c",destination_saves[i][j]);
//        }
//        printf("\n");

        printf("%s\n",destination_saves[i]);
    }

    //***************************CREATE LOG FILE LOCATION + NAME*************************************************************
    //int exeNameLength = 0; //prep (these will sum to pathLength-1 b/c ditch last /
    int pathExeLogLength = 0; //prep

//    k = 0; //using as a flag to hold first / found
//    for(i = pathLength-1; i > 0; i--)
//    {
//        if(path[i] == '\\')
//        {
//            k = i; // save the location
//            break; //escape~
//        }
//    }
    //printf("First / happened at %d\n",k);

    //char exeName[pathLength-k-1]; //prep
    pathExeLogLength = pathLength-4+13+1; //record, 13 for -backup.log"'s and 1 for the \0 at the end while -4 removes .exe
    if(pathExeLogLength > (maxLocaleLength-1) )
    {
        //No fix right now, shouldn't happen
        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
        printf("\n************************************************************************************\n");
        printf("ERROR: Log path length is greater than allocated - %d vs allocated %d.\n",pathExeLogLength,(maxLocaleLength-1) );
        system("pause"); //pause for user input
        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
        return 4; //4 for sass
    }
    char pathExeLog[pathExeLogLength]; //prep,cut off the exe
    char pathExeLogNoParenth[pathExeLogLength-2]; //prep, cut off the exe and dont add "'s
    pathExeLog[0] = '"';
    pathExeLog[pathExeLogLength-1] = '\0';

    //Get path and excutable name separately
    for(i = 1; i <= (pathLength-4); i++)
    {
        pathExeLog[i] = pathHolder[i-1];

    }

    char pathExeLogTemp[13] = "-backup.log\""; //prep constant insert
    pathExeLogTemp[12] = '\0'; //null the end
    for(i = (pathLength-3); i < (pathExeLogLength-1);  i++)
    {
        pathExeLog[i] = pathExeLogTemp[i-(pathLength-3)];
    }
    pathExeLog[pathExeLogLength-1] = '\0'; //make sure it is nulled
    for(i = 1; i < (pathExeLogLength-2); i++ )
    {
        pathExeLogNoParenth[i-1] = pathExeLog[i]; //record
    }
    pathExeLogNoParenth[pathExeLogLength-3] = '\0'; //null it at the end
    //printf("%s\n",pathExeLogNoParenth);


    //***************************CREATE COMMAND AND CALL IT*************************************************************
    roboWarningLogNumberFinder = floor(log10(abs(saves_number))) + 1; //nifty calc for number of number places, e.g. 10 is 2, 100 is 3
    char roboWarningLogNumber[roboWarningLogNumberFinder]; //prep
    int roboWarningLogSaveLength = roboWarningLogSaveAdditionLength + roboWarningLogNumberFinder+1; //only number it so its ez, +1 for null at the end
    char roboWarningLogSave[roboWarningLogSaveLength]; //prep
    for(i = 0; i < roboWarningLogNumberFinder; i++)
    {
        roboWarningLogNumber[i] = '\0'; //prep with nulls
    }
    for(i = 0; i < roboWarningLogSaveLength; i++)
    {
        roboWarningLogSave[i] = '\0'; //prep with nulls
    }
    if( roboWarningLogSaveLength > (maxLocaleLength-1))
    {
        //No fix right now, shouldn't happen
        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
        printf("\n************************************************************************************\n");
        printf("ERROR: Log file name length is greater than allocated - %d vs allocated %d.\n",roboWarningLogSaveLength,(maxLocaleLength-1) );
        system("pause"); //pause for user input
        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
        return 4; //4 for sass
    }

    printf("\nBEGINNING BACKUP\n");
    for(i = 0; i < saves_number; i++)
    {
        commandSize = 9+commandTemp2Size+saves_localesLength[i]+5+strlen(destination_saves[i])+pathExeLogLength; //get the length expected - 9 is for robocopy, 28 is for options, 5 is for space and 4 "'s
        command = (char*)malloc(commandSize * sizeof(char)); //dynamically allocate memory for it
        strcpy(command, commandTemp1);
        strcat(command, "\"");
        strcat(command, saves_locales[i]);
        strcat(command, "\" \"");
        strcat(command, destination_saves[i]);
        strcat(command, "\"");
        strcat(command, commandTemp2);
        strcat(command, pathExeLog);
        //printf("for %d, cmd is %s\n",i,command);
        printf("*********************Backing up: %s*********************\n",saves_locales[i]);
        //system("pause");

        //Below: update system tray icon with current backup info
        for(j = 0; j < nidszTipLength; j++ ) //fillin with nulls
        {
            nid.szTip[j] = '\0'; //fill with nulls
        }
        for(j = 0; j < maxLocaleLength; j++) //fillin with nulls
        {
            sysTrayTemp1[j] = '\0'; // fill with nulls
            sysTrayTemp2[j] = '\0'; // fill with nulls
        }
        strncpy(sysTrayTemp1, "Backing up",nidszTipLength);
        snprintf(sysTrayTemp2,nidszTipLength," %d/%d: ",i+1,saves_number);
        strncat(sysTrayTemp1, sysTrayTemp2, nidszTipLength - strlen(sysTrayTemp1) );
        strncat(sysTrayTemp1, saves_locales[i], nidszTipLength-strlen(sysTrayTemp1) );
        if( sysTrayTemp1[nidszTipLength-1] != '\0' )
        {
            sysTrayTemp1[nidszTipLength-3] = '.'; //dot dot
            sysTrayTemp1[nidszTipLength-2] = '.'; //dot dot
            sysTrayTemp1[nidszTipLength-1] = '\0'; //null terminate
        }
        strcpy(nid.szTip,sysTrayTemp1); //copy over the string

        Shell_NotifyIcon(NIM_MODIFY, &nid); //updates text in system tray

        m = system(command); //run the command
        //m = 0; //for testing, disables robocopy error catch
        //printf("###########  m was %d  ###############\n",m);

        //ROBOCOPY ERROR CODES (some aren't errors tho ayy) - from https://blogs.technet.microsoft.com/deploymentguys/2008/06/16/robocopy-exit-codes/
        //Code 	Meaning
        //0 	No errors occurred and no files were copied.
        //1 	One of more files were copied successfully.
        //2 	Extra files or directories were detected.  Examine the log file for more information.
        //4 	Mismatched files or directories were detected.  Examine the log file for more information.
        //8 	Some files or directories could not be copied and the retry limit was exceeded.
        //16 	Robocopy did not copy any files.  Check the command line parameters and verify that Robocopy has enough rights to write to the destination folder.

        //I HANDLE 8/16 as issues (idk if they all are - 16 is for sure), and support two specific errors in 16
        if(m == 2 || m == 3)
        {
            printf("\nWARNING in Robocopy: Extra files or directories detected - not sure? But I think it is ok.\n");
        }
        else if(m == 4 || m == 5 || m == 6 || m == 7)
        {
            printf("\nWARNING in Robocopy: Mismtached files or directories detected - I think it is deleting files that don't exist in the source anymore, should be ok but noting!\n");
        }
        else if(m == 8 || m == 9 || m == 10 || m == 11 || m == 12 || m == 13 || m == 14 || m == 15)
        {
            if(i == 0 )
            {
                n = 1; //math on logs no go good with 0, force digit to be 1, , e.g. 1 is 1, 10 is 2
            }
            else
            {
                n = floor(log10(abs(i))) + 1; //calc number of digits, e.g. 10 is 2, 100 is 3
            }
            snprintf(roboWarningLogNumber, roboWarningLogNumberFinder, "%d", i+1); //put the number into characters
            if( n < roboWarningLogNumberFinder ) //if too little digits
            {
                for(j = 0; j < (roboWarningLogNumberFinder-n); j++)
                {
                    roboWarningLogSave[j] = '0'; //put in a place holder 0
                }
                for(j = (roboWarningLogNumberFinder-n); j < (roboWarningLogNumberFinder); j++)
                {
                    roboWarningLogSave[j] = roboWarningLogNumber[j-(roboWarningLogNumberFinder-n)]; //put in the number now
                }
            }
            else
            {
                snprintf(roboWarningLogSave, roboWarningLogSaveLength, "%d", i+1); //put in the digits as they take up the whole space (success)
            }

            for(j = roboWarningLogNumberFinder; j < (roboWarningLogSaveAdditionLength+roboWarningLogNumberFinder); j++)
            {
                roboWarningLogSave[j] = roboWarningLogSaveAddition[j-roboWarningLogNumberFinder]; //put in the final .log stuff
            }
            roboWarningLogSave[j+1] = '\0'; //real fast tack a null on after below comment
            //NOTABENE: I DID THIS REAL FAST AND I DID NOT FORCE A NULL AT THE END OF roboWarningLogSave so %s MAY GET WEIRD BUT THATS OK I HOPE WHATEVER F

            //printf("\n%s | and n = %d and est max # = %d\n",roboWarningLogSave,n,roboWarningLogNumberFinder);
            printf("\nWARNING in Robocopy: Failed to copy some files but other files copied successfully. Re-running Backup.exe again my fix this issue (idk bb it did when I made this code to handle this)\n");
            printf("The source directory was %s\nThe log file can be found in %s (corresponds to line # in the Backup_saveLocales.txt list)\nLog file is in same directory as main log file and Backup.exe\nCONTINUING ON\n\n",saves_locales[i],roboWarningLogSave);

            fcheck = fopen(pathExeLogNoParenth,"r"); //read log
            fchecklog = fopen(roboWarningLogSave,"w"); //prep to write log to new name
            if( fchecklog == NULL )
            {
                ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
                printf("\n************************************************************************************\n");
                printf("ERROR TRYING TO SAVE ROBOCOPY LOG OF A FILE COPY FAILURE: IDK WHY IT FAILED TO MAKE A COPY OF THE LOG FILE TO %s IN THE Backup.exe directory. Exiting - fix it pls.\n",roboWarningLogSave);
                fclose(fcheck); //wrap it up
                system("pause"); //pause for user input
                Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
                return 3; //return 3 for sass
            }
            while( ( c = fgetc(fcheck) ) != EOF )
            {
                fputc(c, fchecklog); //write the original log to a specially-named log file
            }
            fclose(fcheck);
            fclose(fchecklog); //wrap it up
        }
        else if(m == 16) //general error check is occuring - specific ones are checked for and if not found the general error is issued
        {
            fcheck = fopen(pathExeLogNoParenth,"r"); //read backup destination
            j = 0; //prep counter
            k = 0; //prep flag
            while( (c = fgetc(fcheck)) != EOF ) //runs till hits end of file
            {
                //printf("%c",c);
                if(c == roboErrorTwo[j])
                {
                    k = 1;
                    if( c ==  roboErrorTwo[roboErrorTwoLength-1] )
                    {
                        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
                        printf("\n************************************************************************************\n");
                        printf("ERROR 2 IN ROBOCOPY (Error code %d): Source location of '%s' was not found to exist. Backup of that folder has failed. Exiting - fix it pls.\n",m,saves_locales[i]);
                        fclose(fcheck); //wrap it up
                        system("pause"); //pause for user input
                        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
                        return 3; //return 3 for sass
                    }
                }
                else if(c == roboErrorThree[j])
                {
                    k = 1;
                    if( c ==  roboErrorThree[roboErrorThreeLength-1] )
                    {
                        ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
                        printf("\n************************************************************************************\n");
                        printf("ERROR 3 IN ROBOCOPY (Error code %d): Destination drive of '%s' was not found to exist. Backup of any files and folders has failed. Exiting - fix it pls.\n",m,destination);
                        fclose(fcheck); //wrap it up
                        system("pause"); //pause for user input
                        Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
                        return 3; //return 3 for sass
                    }
                }
                else
                {
                    k = 0; //Reset K if no consecutive error was caught
                    j = 0; //reset j too
                }

                if(k > 0)
                {
                    k = 0; //flag handles
                    j = j + 1; //increment
                }
            }
            ShowWindow( hWnd, SW_SHOWNA ); //bring the window back into the world because of an issue/error
            printf("\n************************************************************************************\n");
            printf("ERROR IN ROBOCOPY: Not sure what but the exit code wasn't 0 or 1. YOUR ERROR CODE: %d\n0 = OK, no new files\n1 = OK, new files\n2 = Extra files/directories detected see log (not error)\n",m);
            printf("4 = Mismatched files/directories detected see log (not error)\n8 = Some files/directories could not be copied and exceeded retry limit (seems solid error zone less srry)\n");
            printf("16 = nothing copied due to issue, check log, there's a catch for 2 #16 errors already too!\n Exiting - fix it pls, (SEE LOG FILE!).\n");
            fclose(fcheck); //wrap it up
            system("pause"); //pause for user input
            Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done
            return 3; //return 3 for sass
        }
    }
    printf("\n************************************************************************************\n");
    printf("BACKUP WAS COMPLETED SUCCESSFULLY AYY");
    printf("\n************************************************************************************\n");

    printf("\nWaiting 5 seconds so you can read some stuff and then exiting.\n");
    strcpy(nid.szTip, "Basic Bitch Backup has completed successfully"); //tooltip for the icon
    Shell_NotifyIcon(NIM_MODIFY, &nid); //updates system tray icon
    nid.szTip[45] = '\0'; //null at the end of it
    sleep(5); //keep awake for 5 seconds after finished
    Shell_NotifyIcon(NIM_DELETE, &nid); //deletes system tray icon when done

    return 0;
}


//This doesn't work at all - not sure how it's supposed to "capture" mouse without a constant loop (?) who knows everyone on the internet is bad at explaining anything
//Miracle I got the system tray icon to work only C++ examples luckily very little changes sometimes
//Def is hWnd the same? who knows
/*
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        //case WM_CREATE:
        //     break;
        case WM_MYMESSAGE:
            switch(lParam)
             {
                case WM_LBUTTONDBLCLK:
                     ShowWindow( hWnd, SW_SHOW ); //bring the window back into the world because of an issue/error
                     break;
                default:
                    return DefWindowProc(hWnd, msg, wParam, lParam);
             };
             break;
        default:
            return DefWindowProc(hWnd, msg, wParam, lParam);
    };

    return 0;
}
*/
